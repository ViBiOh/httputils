// Code generated by MockGen. DO NOT EDIT.
// Source: cache.go
//
// Generated by this command:
//
//	mockgen -source cache.go -destination ../mocks/cache.go -package mocks -mock_names RedisClient=RedisClient
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	redis "github.com/redis/go-redis/v9"
	gomock "go.uber.org/mock/gomock"
)

// RedisClient is a mock of RedisClient interface.
type RedisClient struct {
	ctrl     *gomock.Controller
	recorder *RedisClientMockRecorder
}

// RedisClientMockRecorder is the mock recorder for RedisClient.
type RedisClientMockRecorder struct {
	mock *RedisClient
}

// NewRedisClient creates a new mock instance.
func NewRedisClient(ctrl *gomock.Controller) *RedisClient {
	mock := &RedisClient{ctrl: ctrl}
	mock.recorder = &RedisClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *RedisClient) EXPECT() *RedisClientMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *RedisClient) Delete(ctx context.Context, keys ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *RedisClientMockRecorder) Delete(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*RedisClient)(nil).Delete), varargs...)
}

// Enabled mocks base method.
func (m *RedisClient) Enabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Enabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Enabled indicates an expected call of Enabled.
func (mr *RedisClientMockRecorder) Enabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enabled", reflect.TypeOf((*RedisClient)(nil).Enabled))
}

// Expire mocks base method.
func (m *RedisClient) Expire(ctx context.Context, ttl time.Duration, keys ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, ttl}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Expire", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Expire indicates an expected call of Expire.
func (mr *RedisClientMockRecorder) Expire(ctx, ttl any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, ttl}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expire", reflect.TypeOf((*RedisClient)(nil).Expire), varargs...)
}

// Load mocks base method.
func (m *RedisClient) Load(ctx context.Context, key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", ctx, key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Load indicates an expected call of Load.
func (mr *RedisClientMockRecorder) Load(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*RedisClient)(nil).Load), ctx, key)
}

// LoadMany mocks base method.
func (m *RedisClient) LoadMany(ctx context.Context, keys ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadMany", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadMany indicates an expected call of LoadMany.
func (mr *RedisClientMockRecorder) LoadMany(ctx any, keys ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadMany", reflect.TypeOf((*RedisClient)(nil).LoadMany), varargs...)
}

// Pipeline mocks base method.
func (m *RedisClient) Pipeline() redis.Pipeliner {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pipeline")
	ret0, _ := ret[0].(redis.Pipeliner)
	return ret0
}

// Pipeline indicates an expected call of Pipeline.
func (mr *RedisClientMockRecorder) Pipeline() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pipeline", reflect.TypeOf((*RedisClient)(nil).Pipeline))
}

// PublishJSON mocks base method.
func (m *RedisClient) PublishJSON(ctx context.Context, channel string, value any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishJSON", ctx, channel, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishJSON indicates an expected call of PublishJSON.
func (mr *RedisClientMockRecorder) PublishJSON(ctx, channel, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishJSON", reflect.TypeOf((*RedisClient)(nil).PublishJSON), ctx, channel, value)
}

// Store mocks base method.
func (m *RedisClient) Store(ctx context.Context, key string, value any, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, key, value, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *RedisClientMockRecorder) Store(ctx, key, value, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*RedisClient)(nil).Store), ctx, key, value, ttl)
}

// StoreMany mocks base method.
func (m *RedisClient) StoreMany(ctx context.Context, values map[string]any, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreMany", ctx, values, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreMany indicates an expected call of StoreMany.
func (mr *RedisClientMockRecorder) StoreMany(ctx, values, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreMany", reflect.TypeOf((*RedisClient)(nil).StoreMany), ctx, values, ttl)
}

// Subscribe mocks base method.
func (m *RedisClient) Subscribe(ctx context.Context, channel string) (<-chan *redis.Message, func(context.Context)) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, channel)
	ret0, _ := ret[0].(<-chan *redis.Message)
	ret1, _ := ret[1].(func(context.Context))
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *RedisClientMockRecorder) Subscribe(ctx, channel any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*RedisClient)(nil).Subscribe), ctx, channel)
}
